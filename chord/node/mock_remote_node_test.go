// Code generated by mockery v1.0.0. DO NOT EDIT.

package node

import (
	context "context"

	chord "github.com/kevinjqiu/chordio/chord"

	mock "github.com/stretchr/testify/mock"

	pb "github.com/kevinjqiu/chordio/pb"
)

// MockRemoteNode is an autogenerated mock type for the RemoteNode type
type MockRemoteNode struct {
	mock.Mock
}

// AsProtobufNode provides a mock function with given fields:
func (_m *MockRemoteNode) AsProtobufNode() *pb.Node {
	ret := _m.Called()

	var r0 *pb.Node
	if rf, ok := ret.Get(0).(func() *pb.Node); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pb.Node)
		}
	}

	return r0
}

// ClosestPrecedingFinger provides a mock function with given fields: ctx, id
func (_m *MockRemoteNode) ClosestPrecedingFinger(ctx context.Context, id chord.ID) (Node, error) {
	ret := _m.Called(ctx, id)

	var r0 Node
	if rf, ok := ret.Get(0).(func(context.Context, chord.ID) Node); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Node)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, chord.ID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindPredecessor provides a mock function with given fields: ctx, id
func (_m *MockRemoteNode) FindPredecessor(ctx context.Context, id chord.ID) (Node, error) {
	ret := _m.Called(ctx, id)

	var r0 Node
	if rf, ok := ret.Get(0).(func(context.Context, chord.ID) Node); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Node)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, chord.ID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindSuccessor provides a mock function with given fields: ctx, id
func (_m *MockRemoteNode) FindSuccessor(ctx context.Context, id chord.ID) (Node, error) {
	ret := _m.Called(ctx, id)

	var r0 Node
	if rf, ok := ret.Get(0).(func(context.Context, chord.ID) Node); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Node)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, chord.ID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBind provides a mock function with given fields:
func (_m *MockRemoteNode) GetBind() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetID provides a mock function with given fields:
func (_m *MockRemoteNode) GetID() chord.ID {
	ret := _m.Called()

	var r0 chord.ID
	if rf, ok := ret.Get(0).(func() chord.ID); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(chord.ID)
	}

	return r0
}

// GetPredNode provides a mock function with given fields:
func (_m *MockRemoteNode) GetPredNode() NodeRef {
	ret := _m.Called()

	var r0 NodeRef
	if rf, ok := ret.Get(0).(func() NodeRef); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(NodeRef)
		}
	}

	return r0
}

// GetSuccNode provides a mock function with given fields:
func (_m *MockRemoteNode) GetSuccNode() NodeRef {
	ret := _m.Called()

	var r0 NodeRef
	if rf, ok := ret.Get(0).(func() NodeRef); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(NodeRef)
		}
	}

	return r0
}

// String provides a mock function with given fields:
func (_m *MockRemoteNode) String() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// UpdateFingerTableEntry provides a mock function with given fields: ctx, s, i
func (_m *MockRemoteNode) UpdateFingerTableEntry(ctx context.Context, s Node, i int) error {
	ret := _m.Called(ctx, s, i)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Node, int) error); ok {
		r0 = rf(ctx, s, i)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// setNodeFactory provides a mock function with given fields: f
func (_m *MockRemoteNode) setNodeFactory(f factory) {
	_m.Called(f)
}
